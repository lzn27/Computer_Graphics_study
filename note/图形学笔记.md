# introduction
- 图形学三大问题:
1. 造型：物体的表示，形状表示、各种物理属性（反射系数、）
2. 运动控制-计算机动画方向
3. 显示（Display）：把造型好的三维图形转换为数字图像

# 2D algorithm 
1. raterization 光栅化：决定用哪些像素表示这个物体。

2. 画直线：
    - DDA算法（递增）：根据直线方程进行x，y递增
    - bresenham算法：比DDA更快，更准确（看更靠近哪个像素点），因为使用位运算（*2）且是整数运算（通过等式两边乘上分母去掉小数运算）。

3. 画圆：
    - 参数方程画圆：如何加速？方法：递推展开
    - y=f(x)  ->  explicit curve 显式曲线  -->  直接采样容易画
    - x=x(t),y=y(t)  ->  parametric curve 参数曲线  -->  直接采样容易画
    - g(x,y) = 0  ->  implicit curve 隐式曲线  -->  问题：如何绘制隐式曲线？答：采样取像素点，判断f(x,y)的正负号，正的一种颜色，负的另一种颜色，最终曲线就可以显示出来。加速？
        1. 均匀网格，降低分辨率，提高速度。可以推广到三维空间，是常用的方法。
        2. chain coding 重随法，先找到线上一点，在内部向左转走一格，在外部向右转走一格。在邻域中找：先找到线上一个点，按当前斜率方向走一格，若在外面，则按照梯度回到曲线上，不断反复画出曲线。  
    实际 -> 画圆的bresenham算法（类似于直线）

4. polygon filling 多边形填充
    - 判断一个点在多边形内部：
        1. 发射射线，判断交点数量的奇偶。如何加速？
        2. 与所有顶点连起来，转角和为360°
        - 扫描线算法：使用直线与多边形的边相交，求得交点，交点把线分为了多个线段，交点1，2的线段在内部，线段3，4在外部.......判断点转化到判断线 -> scan method扫描线算法（图形学经典算法），扫描线算法使用DDA递增方法进一步加速，达到不需要求交点目的。（图形学中尽量避免求交点）。
            - 特殊情况，扫描线过交点（判断是不是极值点），扫描线过边（不处理）
        当前主流算法：扫描线算法
        - seed fill 种子填充算法：已知一个在多边形内部的点p，和多边形的边占用的像素点，根据点p递归地填充所有的内部点。
            - 注意点：4-connected 4邻域：填充不完整。8-connected 8邻域可以填充完整。

# OpenGL
### 1. what is opengl ?
最开始计算机只提供一个setpixel()函数，画图很复杂。微软与SGI合作出了OpenGL（后来微软又抛了OpenGL出了DirectX）。\
OpenGL是开源的图形硬件的软件接口，是一个多平台的图形API，帮助渲染与显示，提供跨平台的工具包GLUT。

### 2. what OpenGL does ?
    - 定义物体形状、材质属性、光照
    - 物体摆放
    - 光栅化
    - 计算颜色
    - 四个库：OpenGL/GLU/GLUT/GLUI
    - OpenGL是一个状态机，参数的设置会一直持续到下一次修改。（初始有默认值）

# aliasing 走样
1. 走样原因：像素点是有大小的，显示设备分散显示固有的缺陷。（例子：锯齿状的曲线）
2. 方法：边界像素点对内外不同颜色进行加权平均显示颜色。
    - 对于不容易计算比例的曲线，可以使用超采样，比如平均取9个点，按内外所属算比例。
    - 实现的效果：边界模糊。

# clipping 裁剪
1. line clipping 线段裁剪（无法避免求交点）Cohen-Sutherland Line Clipping （编码算法）目的是尽量为线段分类，加速判断是否需要裁剪。
2. Sutherland-Hodgeman Polygon-Clipping Algorithm 多边形裁剪（详细见网站）处理多边形的每一条线段与屏幕边沿的关系，输出有效点，把多边形看成是多个点的序列。

# Transformations 变换
1. Geometric Transformations 几何变换，在同一坐标系中对物体进行姿态变换。 
2. viewing transformation 物体姿态不变，坐标描述从一个坐标系中转换到另一个坐标系中。

# Geometric Transformations 几何变换
1. translation 平移 x->x+t y->y+t z->z+t
2. Scaling 缩放/变比 x->x*tx y->y*ty z->z*tz 物体参考于坐标原点的缩放。若需要参考于重心缩放，可以先平移到原点缩放再平移回去，也可以直接原位置缩放再平移回去（要计算好平移量）。scaling一个负数，可以获得图形按坐标抽的对称图形。
3. Rotation 旋转 x=x*cos(t)-y*sin(t), y=x*sin(t)+y*cos(t), z=z（二维）, 按坐标原点的逆时针旋转 t 角。若要按某一指定的点旋转，可以先平移到原点，再旋转，最后再平移回去。
4. Shearing 切变 x->x+a*y, y->y, z->z, 即y值越大的点在x方向上平移的越多。
5. 齐次坐标：General Linear Transformation 左乘一个三维方阵，只能表示缩放与旋转，无法表示平移。所以引入 “齐次坐标” (homogeneous co-ordinates)。
    - 定义：(x,y)->(x',y',a)，其中x=x'/a, y=y'/a。例子：(x,y,1)是(x,y)的一个齐次坐标。
    - any point (x,y,z) in Cartesian co-ordinates is written as (x*w,y*w,z*w,w), w!=0 in Homogeneous Co-ordinates.
    - the point (x,y,z,w) represents (x/w,y/w,z/w) in Cartesian co-ordinates when w!=0.
    - if w==0, (x,y,z,0) represents a point far away.
    - OpenGL中用的就是齐次坐标。
6. 约定：三维中，绕着一个轴旋转t角度，方向使用右手决定，大拇指指向这个轴的方向，旋转方向是四个手指握起来的顺向。
7. 使用齐次坐标的好处：可以把复合变换的多个矩阵合并成一个矩阵，可以加速。只满足结合律，通常不满足交换律。
   
8. 几何变换应该先其它线性变换再平移。
   
#### 问题：三维中绕任意轴旋转？
- 思路：设绕直线L进行旋转，先把L经平移旋转旋转到一个坐标轴上，然后进行rotation变换，完成后，再旋转旋转平移回去。一共左乘7个变换。
  
- 细节：设将直线变换到z坐标轴，则需要先平移一个点到原点，然后绕x轴将直线旋转到xoz平面，最后绕y轴旋转到与z轴重合。旋转角度可以通过随便取一点算出。
  
- Rodrigues' Rotation Formula 罗德里格斯公式（3维绕任意轴旋转）
    - 矩阵R=(n,a)=cosa*I+(1-cosa)nnT+sina(0,-nz,ny//nz,0,-nx//-ny,nx,0)其中n维旋转轴单位向量，a是旋转角度，nT是n的转置，I是单位矩阵。sina后面的一长串是3x3的矩阵。

# transforms in OpenGL
- model-view matrix几何变换
- projection matrix投影
- texture matrix纹理

#### Current Transformation Matrix（CTM）
- 位于栈顶的矩阵，所有要画的点都要先左乘该矩阵。
- Rotate an object by 45 degrees about the line from (4.0,5.0,6.0) to (5.0,7.0,9.0). 
```c++
    glMatrixMode(GL_MODEVIEW);//几何变换，调用该堆栈？
    glLoadIdentity();//把CTM设为单位矩阵。
    glTranslatef(4.0,5.0,6.0);//正值
    glRotatef(45.0,1.0,2.0,3.0);
    glTranslatef(-4.0,-5.0,-6.0);//负值，OpenGL中平移顺序是反的，移动的是坐标系？

    //--矩阵堆栈的push pop操作。
    glPushMatrix();//复制一份当前的CTM然后push到栈顶。后面使用新的栈顶的CTM。
    glPopMatrix();
```
## 问题：OpenGL中用的是行向量还是列向量？这关系到左乘还是右乘。    
OpenGL使用列向量，矩阵左乘。DirectX使用行向量，矩阵右乘。

# Viewing transformation 观察（观测）变换
## 1. view/camera（视图） transformation
1. 确认相机的坐标系，一般来说相机放在(0,0,0)，向-Z方向看，向上是Y
2. 旋转矩阵是正交矩阵，它的逆等于转置。
3. 视图变换就是将世界坐标系表示转换为相机坐标系表示。
4. 视图变换先平移再旋转
   - 视图变换矩阵 M=R<sub>view</sub>*T<sub>view</sub>，R是旋转，T是平移
     
   - T<sub>view</sub>矩阵：其中 x<sub>e</sub>, y<sub>e</sub>, z<sub>e</sub> 是以新坐标系维参考系，原始坐标系的原点坐标
    $$
    \begin{bmatrix}
    1 & 0 & 0 & -x_e\\
    0 & 1 & 0 & -y_e\\
    0 & 0 & 1 & -z_e\\
    0 & 0 & 0 & 1
    \end{bmatrix}
    $$
   - R<sub>view</sub>矩阵：Rotate g to -Z, t to Y, (g x t) to X, 其中g，t是以新坐标系维参考系的两个原始坐标系轴的单位向量
    $$
    \begin{bmatrix}
    x_{g\times t} & y_{g\times t} & z_{g\times t} & 0\\
    x_t & y_t & z_t & 0\\
    x_{-g} & y_{-g} & z_{-g} & 0\\
    0 & 0 & 0 & 1
    \end{bmatrix}
    $$
## 2. Projection Transformation 投影变换
view transformation做好后就到了投影。
### 2.1 Orthographic Projection 正交投影
1. drop z, 标准正交投影先不做drop, 只要先转换成空间内[-1,1]标准立方体。
2. 约定俗成，投影完，缩放到[-1,1]标准立方空间内。
   以下两个矩阵相乘得到正交投影矩阵：前一个是缩放，后一个是平移，先平移再缩放。left,right,bottom,top
   $$
    \begin{bmatrix}
    2/(r-l) & 0 & 0 & 0\\
    0 & 2/(t-b) & 0 & 0\\
    0 & 0 & 2/(n-f) & 0\\
    0 & 0 & 0 & 1
    \end{bmatrix}
    $$
    $$
    \begin{bmatrix}
    1 & 0 & 0 & -(r+l)/2\\
    0 & 1 & 0 & -(t+b)/2\\
    0 & 0 & 1 & -(n+f)/2\\
    0 & 0 & 0 & 1
    \end{bmatrix}
    $$
### 2.2 Perspective Projection 透视投影
1. 近平面距离 n，远平面距离 f
2. first "squish" the frustum into a cuboid. Then do orthographic projection. 先把截头锥体挤压成一个长方体，然后做正交投影就可以了。
    - 挤压的矩阵：
        $$
        \begin{bmatrix}
        n & 0 & 0 & 0\\
        0 & n & 0 & 0\\
        0 & 0 & n+f & -nf\\
        0 & 0 & 1 & 0
        \end{bmatrix}
        $$
    - 思考：介于n和f 之间的点在挤压之后，它的z值是变近了还是变远了？答案：**变远了。**

### 2.3 定义近平面
- aspect redio=width/height
- eye fov垂直可视角度 

<!-- 
----------------------------------
目的：为了方便做投影。
1. World Coordinate System 世界坐标系
2. view coordinate system 观察坐标系
3. Device Coordinates 设备坐标系（屏幕分辨率）

#### 2D方法:
- window：世界坐标系中看到的区域。
- viewport：屏幕上的区域，视口，视域，视区。
- 从window到viewport即世界坐标系到视口坐标系，就是平移->缩放->平移。
```c++
OpenGL：
glViewport(x,y,width,height);//设置视口大小(x,y)是左下角的点
gluOrtho2D(left,right,bottom,top);//设置世界坐标系中的window
//以上两个函数应当比例一致，不然会变形
```

#### 3D方法：Transformations and Camera Analogy 需要以下四步：
- Modeling transformation 造型
- Viewing transformation WCS->VCS
- Projection transformation 投影，得到二维的世界坐标
- Viewport transformation 2D下转换为视口坐标

Perspective Projection 透视投影
- Parallel Projection 平行投影 -> 特：投影方向与投影面垂直时称为 Orthographic Projection 正交投影，正交投影左乘矩阵：

$$
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

- Perspective Projection透视投影
$$
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 1/d & 0
\end{bmatrix}
$$


# 消隐
1. back-face culling 背面剔除，单个物体背面剔除，按平面的法向量正负。
   
2. z-buffer：在图像空间上一个一个像素点进行判断前后，z-buffer存储每个像素点的z值，f-buffer存储每个像素的颜色。
   - 先做透视变换，然后再做正投影，消隐就在做正投影的时候做。
   - Perspective Transformation透视变换
  
3. BSP：在物理空间上考虑，按照面与面之间的相切，建立BSP Tree ，优点：速度快。缺点：只能绘制固定不变的场景。
 
 -->

# Rasterization
* raster--German 德语 屏幕
* picture element--pixel
* 把图打散成像素，即光栅化。
* 隔行扫描-视频压缩，有点：加速。缺点：高速运动画面撕裂
* LCD

triangle
- 最基础的多边形
- 独特性质 三角形一定是平面的
### 判断像素是否在三角形内部：
- A simple Approach :sampling采样
```c
for(int x=0;x<xmax;++x){
    output[x]=f(x)
}

```
判断Q点是否在三角形p0p1p2内部。
使用叉积，p0Q叉积p0p1,p1Q叉积p1p2,p2Q叉积p2p0，三个结果全同号，就在内部。
边界问题：点落在三角形边上。图形学中对于边界问题，要么不做处理，要么特殊处理。

不需要判断所有的像素点，只需要判断三角形的**包围盒(Axis-aligned bounding box: 缩写AABB)**区域：x取值 [min(x0,x1,x2),max(x0,x1,x2)], y取值[min(y0,y1,y2),max(y0,y1,y2)]
bayer pattern

下一讲：锯齿。

# 反走样（抗锯齿）-光栅化2
> 锯齿（aliasing），反锯齿anti-aliasing
1. 摩尔纹（手机拍摄屏幕）
2. 高速车轮看起来倒着转（人眼的采样率不够）
   根本原因：信号变化（频率太高）太快了，采样跟不上
方法：先模糊（先滤波）再采样

- 图像的高频信号部分表示了图像的边界。
- 低通滤波：图像变模糊。高通滤波：图像只剩下边界。带通滤波：介于二者之间，带的宽度可以连续变化以呈现不同的高频低频效果。
- 信号处理：时域的卷积=频域的乘积

### 反走样(anti-aliasing AA)
- 终极方法：提高采样率,即高分辨率
- 先模糊再采样。低通滤波
- MSAA（(Multisample AA）：反走样方法的近似。
  - 把一个像素逻辑上分为多个小像素，算出该大像素在三角形内部的覆盖率，根据覆盖率设置色彩浓度。（其实是在逻辑上提高了采样率）实际工业界会有很多小像素信息复用，4倍抗锯齿fps不会就降4倍。-->光线追踪细说。
- FXAA（Fast Approximate AA）：快速近似，后期处理，先得到锯齿，图像匹配的方法找到锯齿，再把锯齿换掉，速度很快。
- TAA(Temporal AA)：近几年兴起方法，简单高效，时间，静止场景使用，复用上一帧的计算结果。
- 超分辨率，都是要解决锯齿问题。（deep learning）


# z-buffer
- painter's algorithm 画家算法-从低向上画：不能解决相互遮挡
- z-buffer:
  - store current z-value for **each sample(pixel)**
  - Needs an additionam buffer for depth values
    - frame buffer stores color values
    - depth buffer (z-buffer) stores depth
IMPORTANT:For simplicity we suppose z is always positive(smaller z->closer, larger z->further)
```c++
for(every triangle){
    //rasterization
    for(every pixel(x,y,z) in triangle){
        if(z < zbuffer[x][y]){
            zbuffer[x][y] = z;
            framebuffer[x][y] = pixel.color;
        }
    }
}
//O(N)
```
- z-buffer is implemented in hardware for all GPUs.(Most important visibility algorithm)
- 考虑到MSAA反锯齿，z-buffer是对每一个采样点进行深度计算
- z-buffer不能处理透明物体。


# 总结
model-view-projection-rasterization下一步着色

# shading着色
- Definition:
  - Dictionary: the darkening(明暗) or coloring of an illustration or diagram with parallel lines or a block color
  - In CG: The process of applying a matreial to an object

> shading !=shadow 着色!=阴影, 着色是局部的，只考虑该物体。

## Blinn-Phong Reflectance Model
- Specular highlights 高光（镜面反射)
- Diffuse refiection 漫反射
- Ambient lighting 环境光

针对shading point进行考虑：
### Diffuse refiection 漫反射
Ld=Kd(I/r^2)*max(0, n*l)
kd->[0,1],diffuse coefficient
### Ambient lighting 环境光

### Specular highlights 高光（镜面反射）