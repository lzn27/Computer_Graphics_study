# introduction
- 图形学三大问题:
1. 造型：物体的表示，形状表示、各种物理属性（反射系数、）
2. 运动控制-计算机动画方向
3. 显示（Display）：把造型好的三维图形转换为数字图像

# 2D algorithm 
1. raterization 光栅化：决定用哪些像素表示这个物体。

2. 画直线：
    - DDA算法（递增）：根据直线方程进行x，y递增
    - bresenham算法：比DDA更快，更准确（看更靠近哪个像素点），因为使用位运算（*2）且是整数运算（通过等式两边乘上分母去掉小数运算）。

3. 画圆：
    - 参数方程画圆：如何加速？方法：递推展开
    - y=f(x)  ->  explicit curve 显式曲线  -->  直接采样容易画
    - x=x(t),y=y(t)  ->  parametric curve 参数曲线  -->  直接采样容易画
    - g(x,y) = 0  ->  implicit curve 隐式曲线  -->  问题：如何绘制隐式曲线？答：采样取像素点，判断f(x,y)的正负号，正的一种颜色，负的另一种颜色，最终曲线就可以显示出来。加速？
        1. 均匀网格，降低分辨率，提高速度。可以推广到三维空间，是常用的方法。
        2. chain coding 重随法，先找到线上一点，在内部向左转走一格，在外部向右转走一格。在邻域中找：先找到线上一个点，按当前斜率方向走一格，若在外面，则按照梯度回到曲线上，不断反复画出曲线。  
    实际 -> 画圆的bresenham算法（类似于直线）

4. polygon filling 多边形填充
    - 判断一个点在多边形内部：
        1. 发射射线，判断交点数量的奇偶。如何加速？
        2. 与所有顶点连起来，转角和为360°
        - 扫描线算法：使用直线与多边形的边相交，求得交点，交点把线分为了多个线段，交点1，2的线段在内部，线段3，4在外部.......判断点转化到判断线 -> scan method扫描线算法（图形学经典算法），扫描线算法使用DDA递增方法进一步加速，达到不需要求交点目的。（图形学中尽量避免求交点）。
            - 特殊情况，扫描线过交点（判断是不是极值点），扫描线过边（不处理）
        当前主流算法：扫描线算法
        - seed fill 种子填充算法：已知一个在多边形内部的点p，和多边形的边占用的像素点，根据点p递归地填充所有的内部点。
            - 注意点：4-connected 4邻域：填充不完整。8-connected 8邻域可以填充完整。

# OpenGL
### 1. what is opengl ?
最开始计算机只提供一个setpixel()函数，画图很复杂。微软与SGI合作出了OpenGL（后来微软又抛了OpenGL出了DirectX）。\
OpenGL是开源的图形硬件的软件接口，是一个多平台的图形API，帮助渲染与显示，提供跨平台的工具包GLUT。

### 2. what OpenGL does ?
    - 定义物体形状、材质属性、光照
    - 物体摆放
    - 光栅化
    - 计算颜色
    - 四个库：OpenGL/GLU/GLUT/GLUI
    - OpenGL是一个状态机，参数的设置会一直持续到下一次修改。（初始有默认值）

# aliasing 走样
1. 走样原因：像素点是有大小的，显示设备分散显示固有的缺陷。（例子：锯齿状的曲线）
2. 方法：边界像素点对内外不同颜色进行加权平均显示颜色。
    - 对于不容易计算比例的曲线，可以使用超采样，比如平均取9个点，按内外所属算比例。
    - 实现的效果：边界模糊。

# clipping 裁剪
1. line clipping 线段裁剪（无法避免求交点）Cohen-Sutherland Line Clipping （编码算法）目的是尽量为线段分类，加速判断是否需要裁剪。
2. Sutherland-Hodgeman Polygon-Clipping Algorithm 多边形裁剪（详细见网站）处理多边形的每一条线段与屏幕边沿的关系，输出有效点，把多边形看成是多个点的序列。

# Transformations 变换
1. Geometric Transformations 几何变换，在同一坐标系中对物体进行姿态变换。 
2. 物体姿态不变，坐标描述从一个坐标系中转换到另一个坐标系中。

# Geometric Transformations 几何变换
1. translation 平移 x->x+t y->y+t z->z+t
2. Scaling 缩放/变比 x->x*tx y->y*ty z->z*tz 物体参考于坐标原点的缩放。若需要参考于重心缩放，可以先平移到原点缩放再平移回去，也可以直接原位置缩放再平移回去（要计算好平移量）。scaling一个负数，可以获得图形按坐标抽的对称图形。
3. Rotation 旋转 x=x*cos(t)-y*sin(t), y=x*sin(t)+y*cos(t), z=z（二维）, 按坐标原点的逆时针旋转 t 角。若要按某一指定的点旋转，可以先平移到原点，再旋转，最后再平移回去。
4. Shearing 切变 x->x+a*y, y->y, z->z, 即y值越大的点在x方向上平移的越多。
5. 齐次坐标：General Linear Transformation 左乘一个三维方阵，只能表示缩放与旋转，无法表示平移。所以引入 “齐次坐标” (homogeneous co-ordinates)。
    - 定义：(x,y)->(x',y',a)，其中x=x'/a, y=y'/a。例子：(x,y,1)是(x,y)的一个齐次坐标。
    - any point (x,y,z) in Cartesian co-ordinates is written as (x*w,y*w,z*w,w), w!=0 in Homogeneous Co-ordinates.
    - the point (x,y,z,w) represents (x/w,y/w,z/w) in Cartesian co-ordinates when w!=0.
    - if w==0, (x,y,z,0) represents a point far away.
6. 约定：三维中，绕着一个轴旋转t角度，方向使用右手决定，大拇指指向这个轴的方向，旋转方向是四个手指握起来的顺向。