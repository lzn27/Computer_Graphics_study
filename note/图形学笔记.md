# introduction
- 图形学三大问题:
1. 造型：物体的表示，形状表示、各种物理属性（反射系数、）
2. 运动控制-计算机动画方向
3. 显示（Display）：把造型好的三维图形转换为数字图像

# 2D algorithm 
1. raterization 光栅化：决定用哪些像素表示这个物体。

2. 画直线：
    - DDA算法（递增）：根据直线方程进行x，y递增
    - bresenham算法：比DDA更快，更准确（看更靠近哪个像素点），因为使用位运算（*2）且是整数运算（通过等式两边乘上分母去掉小数运算）。

3. 画圆：
    - 参数方程画圆：如何加速？方法：递推展开
    - y=f(x)  ->  explicit curve 显式曲线  -->  直接采样容易画
    - x=x(t),y=y(t)  ->  parametric curve 参数曲线  -->  直接采样容易画
    - g(x,y) = 0  ->  implicit curve 隐式曲线  -->  问题：如何绘制隐式曲线？答：采样取像素点，判断f(x,y)的正负号，正的一种颜色，负的另一种颜色，最终曲线就可以显示出来。加速？
        1. 均匀网格，降低分辨率，提高速度。可以推广到三维空间，是常用的方法。
        2. chain coding 重随法，先找到线上一点，在内部向左转走一格，在外部向右转走一格。在邻域中找：先找到线上一个点，按当前斜率方向走一格，若在外面，则按照梯度回到曲线上，不断反复画出曲线。  
    实际 -> 画圆的bresenham算法（类似于直线）

4. polygon filling 多边形填充
    - 判断一个点在多边形内部：
        1. 发射射线，判断交点数量的奇偶。如何加速？
        2. 与所有顶点连起来，转角和为360°
        - 扫描线算法：使用直线与多边形的边相交，求得交点，交点把线分为了多个线段，交点1，2的线段在内部，线段3，4在外部.......判断点转化到判断线 -> scan method扫描线算法（图形学经典算法），扫描线算法使用DDA递增方法进一步加速，达到不需要求交点目的。（图形学中尽量避免求交点）。
            - 特殊情况，扫描线过交点（判断是不是极值点），扫描线过边（不处理）
        当前主流算法：扫描线算法
        - seed fill 种子填充算法：已知一个在多边形内部的点p，和多边形的边占用的像素点，根据点p递归地填充所有的内部点。
            - 注意点：4-connected 4邻域：填充不完整。8-connected 8邻域可以填充完整。

# OpenGL
### 1. what is opengl ?
最开始计算机只提供一个setpixel()函数，画图很复杂。微软与SGI合作出了OpenGL（后来微软又抛了OpenGL出了DirectX）。\
OpenGL是开源的图形硬件的软件接口，是一个多平台的图形API，帮助渲染与显示，提供跨平台的工具包GLUT。

### 2. what OpenGL does ?
    - 定义物体形状、材质属性、光照
    - 物体摆放
    - 光栅化
    - 计算颜色
    - 四个库：OpenGL/GLU/GLUT/GLUI
    - OpenGL是一个状态机，参数的设置会一直持续到下一次修改。（初始有默认值）

# aliasing 走样
1. 走样原因：像素点是有大小的，显示设备分散显示固有的缺陷。（例子：锯齿状的曲线）
2. 方法：边界像素点对内外不同颜色进行加权平均显示颜色。
    - 对于不容易计算比例的曲线，可以使用超采样，比如平均取9个点，按内外所属算比例。
    - 实现的效果：边界模糊。

# clipping 裁剪
1. line clipping 线段裁剪（无法避免求交点）Cohen-Sutherland Line Clipping （编码算法）目的是尽量为线段分类，加速判断是否需要裁剪。
2. Sutherland-Hodgeman Polygon-Clipping Algorithm 多边形裁剪（详细见网站）处理多边形的每一条线段与屏幕边沿的关系，输出有效点，把多边形看成是多个点的序列。

# Transformations 变换
1. Geometric Transformations 几何变换，在同一坐标系中对物体进行姿态变换。 
2. viewing transformation 物体姿态不变，坐标描述从一个坐标系中转换到另一个坐标系中。

# Geometric Transformations 几何变换
1. translation 平移 x->x+t y->y+t z->z+t
2. Scaling 缩放/变比 x->x*tx y->y*ty z->z*tz 物体参考于坐标原点的缩放。若需要参考于重心缩放，可以先平移到原点缩放再平移回去，也可以直接原位置缩放再平移回去（要计算好平移量）。scaling一个负数，可以获得图形按坐标抽的对称图形。
3. Rotation 旋转 x=x*cos(t)-y*sin(t), y=x*sin(t)+y*cos(t), z=z（二维）, 按坐标原点的逆时针旋转 t 角。若要按某一指定的点旋转，可以先平移到原点，再旋转，最后再平移回去。
4. Shearing 切变 x->x+a*y, y->y, z->z, 即y值越大的点在x方向上平移的越多。
5. 齐次坐标：General Linear Transformation 左乘一个三维方阵，只能表示缩放与旋转，无法表示平移。所以引入 “齐次坐标” (homogeneous co-ordinates)。
    - 定义：(x,y)->(x',y',a)，其中x=x'/a, y=y'/a。例子：(x,y,1)是(x,y)的一个齐次坐标。
    - any point (x,y,z) in Cartesian co-ordinates is written as (x*w,y*w,z*w,w), w!=0 in Homogeneous Co-ordinates.
    - the point (x,y,z,w) represents (x/w,y/w,z/w) in Cartesian co-ordinates when w!=0.
    - if w==0, (x,y,z,0) represents a point far away.
    - OpenGL中用的就是齐次坐标。
6. 约定：三维中，绕着一个轴旋转t角度，方向使用右手决定，大拇指指向这个轴的方向，旋转方向是四个手指握起来的顺向。
7. 使用齐次坐标的好处：可以把复合变换的多个矩阵合并成一个矩阵，可以加速。只满足结合律，通常不满足交换律。
#### 问题：三维中绕任意轴旋转？
- 思路：设绕直线L进行旋转，先把L经平移旋转旋转到一个坐标轴上，然后进行rotation变换，完成后，再旋转旋转平移回去。一共左乘7个变换。
- 细节：设将直线变换到z坐标轴，则需要先平移一个点到原点，然后绕x轴将直线旋转到xoz平面，最后绕y轴旋转到与z轴重合。旋转角度可以通过随便取一点算出。

# transforms in OpenGL
- model-view matrix几何变换
- projection matrix投影
- texture matrix纹理

#### Current Transformation Matrix（CTM）
- 位于栈顶的矩阵，所有要画的点都要先左乘该矩阵。
- Rotate an object by 45 degrees about the line from (4.0,5.0,6.0) to (5.0,7.0,9.0). 
```c++
    glMatrixMode(GL_MODEVIEW);//几何变换，调用该堆栈？
    glLoadIdentity();//把CTM设为单位矩阵。
    glTranslatef(4.0,5.0,6.0);//正值
    glRotatef(45.0,1.0,2.0,3.0);
    glTranslatef(-4.0,-5.0,-6.0);//负值，OpenGL中平移顺序是反的，移动的是坐标系？

    //--矩阵堆栈的push pop操作。
    glPushMatrix();//复制一份当前的CTM然后push到栈顶。后面使用新的栈顶的CTM。
    glPopMatrix();
```
# 问题：OpenGL中用的是行向量还是列向量？这关系到左乘还是右乘。    

# Viewing transformation 观察变换
目的：为了方便做投影。
1. World Coordinate System 世界坐标系
2. view coordinate system 观察坐标系
3. Device Coordinates 设备坐标系（屏幕分辨率）

#### 2D方法:
- window：世界坐标系中看到的区域。
- viewport：屏幕上的区域，视口，视域，视区。
- 从window到viewport即世界坐标系到视口坐标系，就是平移->缩放->平移。
```c++
OpenGL：
glViewport(x,y,width,height);//设置视口大小(x,y)是左下角的点
gluOrtho2D(left,right,bottom,top);//设置世界坐标系中的window
//以上两个函数应当比例一致，不然会变形
```

#### 3D方法：Transformations and Camera Analogy 需要以下四步：
- Modeling transformation 造型
- Viewing transformation WCS->VCS
- Projection transformation 投影，得到二维的世界坐标
- Viewport transformation 2D下转换为视口坐标

Perspective Projection 透视投影
Parallel Projection 平行投影 -> 特：投影方向与投影面垂直时称为 Orthographic Projection 正交投影，正交投影左乘矩阵：

$$
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

1. 从最简单的正交投影开始，可以建立观察坐标系（辅助），把物体在世界坐标系中的坐标转换到观察坐标系中，然后再做投影，此时投影就是一个平移缩放的问题了，最多再加个旋转。



# 消隐

1. z-buffer
2. BSP
